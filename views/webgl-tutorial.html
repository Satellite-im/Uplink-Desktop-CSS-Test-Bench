<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/static/tools.css" type="text/css">
</head>
<body style="display:flex; flex-direction:column; justify-content:space-between;">
    <span>video player</span>
    <canvas id="canvas" width="474" height="474">Browser doesn't support canvas. </canvas>
    <button onclick="play()">start</button>
    <script type="text/javascript" src="/webgl/webgl-utils.js"></script>
    <script type="text/javascript">

let first_click = false;
function play() {
    if (first_click === false) {
        first_click = true;
    } else {
        return;
    }
}

// glsl scripts and webgl2 adapted from this blog post: https://medium.com/docler-engineering/webgl-video-manipulation-8d0892b565b6
// chatgpt "helped" a little here too 

var refs = {};
// the opengl texture, which is bound using gl.bindTexture() and then assigned to using the uniforms
var textures = {};
var attributes = {};
var buffers = {};
var uniforms = {};

const vertexShaderSource = `#version 300 es
in vec2 position;
out vec2 texCoord;
uniform vec2 u_resolution;

void main() {
    gl_Position = vec4(position, 0.0, 1.0);
    // clip space is from -1.0 to 1.0. adding one and dividing by 2 transforms it 
    // to the interval [0, 1.0].
    // then multiply by u_resolution to allow indexing into the texture.
    texCoord = floor(((position + 1.0) * 0.5) * u_resolution);
}
`;

const fragmentShaderSource = `#version 300 es
precision highp float;

in vec2 texCoord;
// these uniforms are 1d textures with GL_R8 internal format
uniform sampler2D y_plane;
uniform sampler2D u_plane;
uniform sampler2D v_plane;
out vec4 fragColor;

void main() {
    float y = texture(y_plane, texCoord).r;
    float u = texture(u_plane, texCoord * 0.25).r;
    float v = texture(v_plane, texCoord * 0.25).r;

    float r = y + 1.402 * v;
    float g = y - 0.344136 * u - 0.714136 * v;
    float b = y + 1.772 * u;

    fragColor = vec4(r, g, b, 1.0);
}
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(`Shader compilation error: ${gl.getShaderInfoLog(shader)}`);
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    if (!vertexShader || !fragmentShader) {
        return null;
    }

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(`Program linking error: ${gl.getProgramInfoLog(program)}`);
        gl.deleteProgram(program);
        return null;
    }

    return program;
}

function init() {
    const canvas = document.querySelector("#canvas") || document.createElement("canvas");
    canvas.width = 474;
    canvas.height = 474;

    const gl = canvas.getContext("webgl2");
    if (!gl) {
        console.error("Unable to initialize WebGL. Your browser may not support it.");
        return;
    }
   
    const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
    gl.useProgram(program);

    // Create a vertex array object (attribute state)
    refs.vao = gl.createVertexArray();
    // and make it the one we're currently working with
    gl.bindVertexArray(refs.vao);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(
        gl.ARRAY_BUFFER, 
        new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]),
        gl.STATIC_DRAW
    );

    const positionLocation = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

    refs.program = program;
    refs.gl = gl;
    refs.canvas = canvas;
}

function render(gl, program, yData, uData, vData, width, height) {
    const yTexture = createTexture(gl, gl.LUMINANCE, yData, width, height);
    const uTexture = createTexture(gl, gl.LUMINANCE, uData, width / 2, height / 2);
    const vTexture = createTexture(gl, gl.LUMINANCE, vData, width / 2, height / 2);

    gl.uniform1i(gl.getUniformLocation(program, "u_y_plane"), 0);
    gl.uniform1i(gl.getUniformLocation(program, "u_u_plane"), 1);
    gl.uniform1i(gl.getUniformLocation(program, "u_v_plane"), 2);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, yTexture);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, uTexture);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, vTexture);

    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function createTexture(gl, format, data, width, height) {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texImage2D(
        gl.TEXTURE_2D, 
        0, 
        format, 
        width, 
        height, 
        0, 
        format, 
        gl.UNSIGNED_BYTE, 
        new Uint8Array(data)
    );
    return texture;
}

init();

const xhr=new XMLHttpRequest();
xhr.open('GET','/static/letter-f.yuv');
xhr.responseType='arraybuffer';
xhr.onload=()=>{
    console.log('got image');
    const data=xhr.response;
    var len = data.byteLength;
    var width = 474;
    var height = 474;
    var y_len = width * height;
    var u_len = y_len / 4;
    var y = data.slice(0, y_len);
    var u = data.slice(y_len, y_len + u_len);
    var v = data.slice(y_len + u_len, y_len + u_len + u_len);

    console.log("len: " + len + " y_len: " + y_len + " u_len: " + u_len);
    render(refs.gl, refs.program, y, u, v, width, height);
}
xhr.send();

// todo: receive images and call render()
// left off here: https://chat.openai.com/c/f4829fe9-0ff2-42a6-bb40-9b0fd98ad6c4

    </script>
</body>
</html>