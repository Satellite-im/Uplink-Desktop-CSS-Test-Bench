<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
    <head>
        <link rel="stylesheet" href="/static/tools.css" type="text/css">
    </head>
<body style="display:flex; flex-direction:column; justify-content:space-between;">
    <span>video player</span>
    <canvas id="canvas" width="512" height="512">Browser doesn't support canvas. </canvas>
    <button onclick="play()">start</button>
    <script type="text/javascript" src="/webgl/webgl-utils.js"></script>
    <script type="text/javascript">

let first_click = false;
function play() {
    if (first_click === false) {
        first_click = true;
    } else {
        return;
    }
}

// webgl2 rendering code was initially generated by chatgpt. 
// input question:
// write a webgl2 program to accept as input an image in yuv 4:2:0 format, transform it into rgb format, and render it on a canvas

// uniforms{} contains const parameters used to convert between yuv and rgb. 
var uniforms = {};
// stores the gl object
var glContext = {};
// the opengl texture, which is bound using gl.bindTexture() and then assigned to using the uniforms
var textures = {};

const vertexShaderSource = `#version 300 es
in vec2 position;
out vec2 texCoord;
void main() {
    gl_Position = vec4(position, 0.0, 1.0);
    texCoord = (position + 1.0) / 2.0;
}
`;

const fragmentShaderSource = `#version 300 es
precision mediump float;
in vec2 texCoord;
uniform sampler2D yTexture;
uniform sampler2D uTexture;
uniform sampler2D vTexture;
out vec4 fragColor;
void main() {
    float y = texture(yTexture, texCoord).r;
    float u = texture(uTexture, texCoord).r - 0.5;
    float v = texture(vTexture, texCoord).r - 0.5;
    float r = y + 1.402 * v;
    float g = y - 0.344136 * u - 0.714136 * v;
    float b = y + 1.772 * u;
    fragColor = vec4(r, g, b, 1.0);
}
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(`Shader compilation error: ${gl.getShaderInfoLog(shader)}`);
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    if (!vertexShader || !fragmentShader) {
        return null;
    }

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(`Program linking error: ${gl.getProgramInfoLog(program)}`);
        gl.deleteProgram(program);
        return null;
    }

    return program;
}

function getUniforms(gl) {
    const yTextureLocation = gl.getUniformLocation(program, "yTexture");
    const uTextureLocation = gl.getUniformLocation(program, "uTexture");
    const vTextureLocation = gl.getUniformLocation(program, "vTexture");

    // i think these only need to be set once and don't need to be set 
    // for each call to render()
    gl.uniform1i(yTextureLocation, 0);
    gl.uniform1i(uTextureLocation, 1);
    gl.uniform1i(vTextureLocation, 2);

    return {
        yTextureLocation: yTextureLocation,
        uTextureLocation: uTextureLocation,
        vTextureLocation: vTextureLocation
    };
}

function getTextures(gl) {
    return {
        yTexture: gl.createTexture(),
        uTexture: gl.createTexture(),
        vTexture: gl.createTexture(),
    };
}

function main() {
    const canvas = document.querySelector("#canvas") || document.createElement("canvas");
    canvas.width = 512;
    canvas.height = 512;

    const gl = canvas.getContext("webgl2");
    if (!gl) {
        console.error("Unable to initialize WebGL. Your browser may not support it.");
        return;
    }
   
    const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
    gl.useProgram(program);

    const positionAttributeLocation = gl.getAttribLocation(program, "position");
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionAttributeLocation);

   // textures ang glContext are needed by render()
   textures = getTextures(gl);
   // it may not be necessary to store these. in a global variable
   uniforms = getUniforms(gl);
   glContext.gl = gl;
}

// todo: input width and height
function render(gl, yData, uData, vData) {
    // Assuming you have the Y, U, and V components in separate arrays 
    gl.bindTexture(gl.TEXTURE_2D, textures.yTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, yData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
   
    gl.bindTexture(gl.TEXTURE_2D, textures.uTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width / 2, height / 2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    
    gl.bindTexture(gl.TEXTURE_2D,textures. vTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width / 2, height / 2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, vData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
   
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

main();

// todo: receive images and call render()

    </script>
</body>
</html>